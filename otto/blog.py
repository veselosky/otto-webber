# encoding: UTF-8
"""Simple blog manager.

General Introduction
====================
Conceptually, a blog is a Channel optionally containing Entries and Channels. A
Channel is simply a directory containing a valid `channel.json` file. An Entry
is a file of the correct EntryType (see under Inputs below).

All objects are represented as simple dictionaries. This ensures they can
easily be serialized to and from JSON, the canonical storage format. The
dictionaries are designed to be compatible with those produced by feedparser.
Consult the feedparser documentation for hints as to useful keys. However,
arbitrary keys are accepted as generic metadata and passed to your template
context unchanged, so long as they do not conflict with (or are compatible
with) feedparser reserved names.

Dictionary keys beginning with an underscore are not stored, but are calculated
and inserted by the load routines. Such keys are not guaranteed to exist. Do
not set them yourself.

Datetime fields are converted to timezone-aware Python datetime.datetime objects.

Inputs
------
All files under the blog channel are considered inputs. All input files are
passed to the output unchanged. Two types of inputs are treated specially:
Channels and Entries. Each input of these types is processed to produce a
separate output file for each configured output format. In the future, output
formats will be configurable. Currently, they are hard-coded to include: JSON,
HTML, and Atom.

A Channel is a directory containing a valid `channel.json` file at its top
level.  The `channel.json` file contains metadata about the Channel which Otto
uses to compose the Channel. It is equivalent to a feedparser "feed" object,
and keys are interpreted with the same semantics. As a metadata file,
`channel.json` is not processed directly into alternate output formats.
However, for each Channel, Otto produces an "index" output of each format,
containing the Channel metadata and the 50 most recent entries in that channel
(but excluding entries in any sub-channels).

An Entry is any file within a Channel that matches a valid EntryType for that
Channel. In future this will be configurable. Currently, the only valid EntryTypes
are Markdown files ('*.md') and JSON files ('*.json'). Markdown inputs are processed
with the 'codehilite', 'extra', and 'meta' extensions.

Outputs
-------
For each Entry or Channel input, Otto will produce an output in each of the
configured output formats. In the future, output formats will be configurable.
Currently, they are hard-coded to include: JSON, HTML, and Atom. The output
will have an identical file name, but with the file extension converted to one
appropriate for the format ('.json', '.html', '.atom').  If you use multiple
extensions to take advantage of Apache's content negotiation, ensure the file
type extension is the LAST one. Otherwise Otto will not recognize it.

JSON output is generated using a custom JSON serializer. Sorry, no user customization
available at this time.

Atom output is generated by Jinja2 templates. At some point in the future,
it may change to use a proper XML generator. Until then, this output may be
somewhat fragile, but should work in the general case.

HTML output is generated using Jinja2 templates. To supply your own templates,
set `env['otto.template_dir']` to their location. Otherwise, Otto will use its
own rather spartan POSH templates (POSH = Plain Old Semantic HTML).

"""
from datetime import datetime
from dateutil import tz, parser as dateparser
from fabric.api import env, lcd, local, require, task as fabtask
from feedparser import FeedParserDict # WARNING! Private internals!
import fnmatch
from jinja2 import Environment, FileSystemLoader
import markdown
import os
import os.path
from otto.util import ancestor_of, slurp, dump, json_dump, json_load, paths
try:
    import simplejson as json
except ImportError:
    import json
import re
import logging

DEFAULT_CONFIG = {
    'otto.blog.html_entry_template': 'entry.html',
    'otto.blog.html_channel_template': 'channel.html',
    'otto.blog.atom_entry_template': 'entry.atom',
    'otto.blog.atom_channel_template': 'channel.atom',
    'otto.blog.template_dir': os.path.join( os.path.dirname(__file__), 'templates')
    }
for k, v in DEFAULT_CONFIG.iteritems():
    env.setdefault(k, v)


# Module cache, only init Jinja once during run
jinja = None
def get_jinja():
    global jinja
    if jinja == None:
        template_dirs = [ env['otto.blog.template_dir'] ]
        if env.has_key('otto.template_dir'):
            template_dirs += env['otto.template_dir']
        jinja = Environment(
            loader=FileSystemLoader(template_dirs),
            extensions=['jinja2.ext.loopcontrols', 'jinja2.ext.autoescape'],
            autoescape=True,
            )
    return jinja


DATETIME_FIELDS = ['created', 'expired', 'published', 'updated']
def normalize_datetimes(thing):
    # Use a timezone-aware default. Otherwise would get naive datetimes.
    default = datetime.now(tz.gettz()).replace(hour=0,minute=0,second=0,microsecond=0)
    for k in DATETIME_FIELDS:
        if thing.has_key(k):
            try:
                dt = dateparser.parse(thing[k], default=default)
            except ValueError:
                continue
            thing[k] = dt
            if not thing.has_key(k+'_parsed'):
                thing[k+'_parsed'] = dt.timetuple()


class BlogThing(FeedParserDict):
    """Code shared by channels and entries."""

    def channel(self):
        """Return the channel containing the Thing. If the Thing IS a channel, returns itself."""
        if self['_metafile'].endswith('channel.json'):
            return self
        channel_dir = ancestor_of(self['_metafile'], containing='channel.json')
        return Channel.load_json(channel_dir)

    @classmethod
    def load_json(cls, filename):
        """Create an object and initialize from JSON file."""
        thing = cls( json_load(filename) )

        # These properties are contextual, therefore calculated and not stored.
        mtime = datetime.utcfromtimestamp(os.path.getmtime(filename))
        thing['_modified'] = mtime
        thing['_metafile'] = filename
        # TODO Media-link entries as defined in AtomPub will have a different contentfile
        if filename.endswith('channel.json'):
            thing['_contentfile'] = os.path.join( os.path.dirname(filename), 'index.json')
        else:
            thing['_contentfile'] = filename

        normalize_datetimes(thing)
        return thing

    def save_json(self, outfile=None):
        """Write the JSON data (back) to disk."""
        outfile = outfile or self['_metafile']
        json_dump(self, outfile)

    def render_to(self, format='html', context={}, outfile=None):
        """Output an HTML file."""
        if not outfile:
            outfile, ext = os.path.splitext(self['_contentfile'])
            outfile = outfile + '.' + format
        # TODO Only write outfile if entry file is newer
        template = self.get_template(format)
        dump(template.render(self.context(context)), outfile)

    def context(self, context={}):
        return context


class Channel(BlogThing):

    @classmethod
    def load_json(cls, filename):
        """Create an object and initialize from JSON file."""
        if os.path.isdir(filename):
            filename = os.path.join(filename, 'channel.json')
        return super(Channel, cls).load_json(filename)

    def save_json(self, outfile=None):
        """Write the JSON data (back) to disk."""
        # Default save location is metadata file, no entries there
        entries = self.pop('entries', None)
        super(Channel, self).save_json()

        # We also produce the index.json which does have the entries
        if entries:
            self['entries'] = entries
            super(Channel, self).save_json(self['_contentfile'])
 
    def context(self, context={}):
        context.update({ "channel": self })
        return context

    def get_template(self, format='html'):
        """Returns a Jinja2 template object that will output the requested format."""
        template_name = self.get(format+'_template', None) or \
            env['otto.blog.%s_channel_template' % format]
        jinja = get_jinja()
        return jinja.get_template(template_name)

    def url(self, absolute=False):
        """URL to the channel, relative to /."""
        channelpath = os.path.dirname(self.channel()['_metafile'])
        relpath = os.path.relpath(paths.build_dir('htdocs'), channelpath)
        if relpath == '.' and absolute:
            return 'http://%s/' % env['otto.site']
        if absolute:
            return 'http://%s/%s/' % (env['otto.site'], relpath)
        return relpath+'/'


class Entry(BlogThing):

    def sort_date(e):
        return e.get('updated', None) or e.get('published', None) or e.get('_modified', None)

    @staticmethod
    def sort_key(e):
        """Key function to be passed to list.sort"""
        return e.sort_date()

    @classmethod
    def load_markdown(cls, filename):
        """Return an Entry loaded from the given path."""
        md = markdown.Markdown(
                extensions=['codehilite', 'extra', 'meta'],
                output_format='html4',
                )
        body = md.convert( slurp(filename) )
        metadata = md.Meta

        # Markdown makes every value a list, just in case. I only want lists if the
        # thing claims to be a list.
        entry = cls()
        for k,v in metadata.iteritems():
            if len(v) == 1 and not k.endswith('_list'):
                entry[k] = v[0]
            else:
                entry[k] = v

        normalize_datetimes(entry)

        # http://packages.python.org/feedparser/reference-entry-content.html
        entry['content'] = [ { 'value': body, 'type': 'text/html' } ]

        # http://packages.python.org/feedparser/reference-entry-tags.html
        tag_list = re.split(r',?\s+', entry.pop('tags', ''))
        entry['tags'] = [ {'term': tag, 'scheme':'', 'label': tag} for tag in tag_list ]

        # These properties are contextual, therefore calculated and not stored.
        entry['_modified'] = datetime.utcfromtimestamp(os.path.getmtime(filename))
        # The JSON file is canonical.
        entry['_sourcefile'] = filename
        entry['_metafile'] = entry['_contentfile'] = re.sub(r'\.md$', '.json', filename)
        return entry

    def get_template(self, format='html'):
        """Returns a Jinja2 template object that will output the requested format."""
        template_name = self.get(format+'_template', None) or \
            self.channel().get(format+'_entry_template', None) or \
            env['otto.blog.%s_entry_template' % format]
        jinja = get_jinja()
        return jinja.get_template(template_name)

    def context(self, context={}):
        context.update({'entry':self, 'channel':self.channel})
        return context

    def bodycontent(self):
        """All the content that's fit to print."""
        return ' '.join( [ x['value'] for x in self['content'] ] )

    def url(self, format=None, absolute=False):
        """URL to the entry, relative to its channel."""
        channelpath = os.path.dirname(self.channel()['_metafile'])
        relpath = os.path.relpath(self['_contentfile'], channelpath)
        url, ext = os.path.splitext(relpath)
        if format:
            url = url + '.' + format
        if absolute:
            return self.channel().url(absolute) + url
        return url

    def topic_list(self):
        """Simple list of "topic" tags as strings (whereas `tags` gives you dicts)."""
        if self.has_key('tags'):
            return [ tag['term'] for tag in self['tags'] ]
        else:
            return []


# TODO 0.5 Accept date argument for incremental build
@fabtask
def build_blog(source_dir, dest_dir):
    """Build the blog"""
    require('otto.build_dir', 'otto.site')
    if not source_dir.endswith('/'):
        source_dir += '/'
    build_dir = paths.build_dir(dest_dir)

    logging.info("Processing " + source_dir)
    with lcd(paths.local_workspace()):
        local('mkdir -p %s' % build_dir)
        local('cp -a %s %s' % (source_dir, build_dir))

    # Walk the dir looking for markdown files and convert to JSON
    for thisdir, subdirs, files in os.walk(build_dir):
        for mdfile in fnmatch.filter(files, '*.md'):
            # TODO Only write outfile if md file is newer
            mdfilename = os.path.join(thisdir, mdfile)
            entry = Entry.load_markdown(mdfilename)
            entry.save_json()

    # Now walk it again, converting each JSON file to HTML and Atom
    entries = []
    for thisdir, subdirs, files in os.walk(build_dir, topdown=False):
        for entryfile in fnmatch.filter(files, '*.json'):
            if entryfile == 'channel.json':
                continue
            entrypath = os.path.join(thisdir, entryfile)
            entry = Entry.load_json(entrypath)
            entries.append(entry)
            entry.render_to('html')
            entry.render_to('atom')

        # Since this is a depth-first crawl, if we have reached the channel dir,
        # we have already processed all the entries in this channel.
        if os.path.exists( os.path.join(thisdir, 'channel.json')):
            channel = Channel.load_json(thisdir)

            # sort entries reverse chrono
            entries.sort(key=Entry.sort_key, reverse=True)
            channel['entries'] = entries
            channel.save_json()
            channel.render_to('html')
            channel.render_to('atom')

